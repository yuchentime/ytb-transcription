# 问题复盘

## 时间
- 2026-02-22

## 问题 1：任务已完成但页面未展示转写/翻译结果

### 现象
- `src/pages/TaskPage.tsx` 中结果区域依赖 `props.model.transcriptContent` 和 `props.model.translationContent` 显示。
- 实际任务处理完成后，页面仍不展示文本结果。

### 根因
- 任务完成事件 `onCompleted` 仅更新了 `output`（文件路径），没有在完成后读取文本并回填 `taskState`。
- `TaskPage` 的折叠区依赖 `taskState.transcriptContent` / `taskState.translationContent`，未回填即无内容可渲染。

### 修复
- 在 `src/app/hooks/useTaskEvents.ts` 的 `onCompleted` 中补充 `loadTaskContentAction(...)` 调用，完成时主动读取 `transcriptPath` 和 `translationPath` 并写回状态。
- 在以下流程中显式清空旧文本状态，避免任务切换时残留旧结果：
  - `startTaskAction`
  - `handleRetryHistoryTaskAction`
  - `loadTaskDetailAction`
  - 删除当前激活任务分支（`handleDeleteHistoryTaskAction`）
- 优化 `loadTaskContentAction`：
  - 当路径缺失时清空对应字段；
  - 当读取失败时清空对应字段并记日志；
  - 移除调试日志输出。

### 验证
- `npx tsc --noEmit` 通过。
- `npm run lint` 通过。
- 手动验证：任务完成后可在任务页看到转写与翻译结果内容。

---

## 问题 2：翻译结果存在局部重复（分段合并后）

### 现象
- 翻译结果中出现局部内容重复，集中发生在分段边界附近。

### 原因分析
- 翻译阶段在最终合并时直接 `join('\n')`，没有做边界去重。
- 模型在部分场景会把 `PREVIOUS_CONTEXT/NEXT_CONTEXT` 一并翻译进 `CURRENT_SEGMENT`，导致相邻段出现重叠文本。
- split fallback（超时后对子段重试翻译）内部也存在直接拼接路径，同样可能引入重复。

### 修复
- 在 `electron/core/task-engine/TaskEngine.ts` 新增翻译块合并去重逻辑：
  - `mergeTranslatedChunk(...)`
  - `mergeTranslatedChunks(...)`
- 将去重合并应用到两处：
  - split fallback 的子片段合并；
  - 翻译阶段最终分段结果合并（替换原 `join('\n')`）。
- 当检测并移除重叠文本时，增加日志：
  - `Translation merge removed duplicated overlap chars=...`
- 在 `electron/core/task-engine/minimax.ts` 增强翻译提示词约束：
  - 明确禁止翻译 `PREVIOUS_CONTEXT` / `NEXT_CONTEXT`；
  - 若出现上下文重复，要求模型先去重后输出。

### 验证
- `npx tsc --noEmit` 通过。
- `npm run lint` 通过。
- 预期效果：相邻分段重复显著减少；即使模型偶发带出上下文，也会在合并阶段进行兜底去重。

---

## 问题 3：Whisper 转录阶段报 SSL EOF（MLX/HuggingFace 下载）

### 现象
- 转录阶段日志出现 `httpcore.ConnectError: [SSL: UNEXPECTED_EOF_WHILE_READING]`。
- 调用栈经过 `http_proxy.py` 和 `huggingface_hub._snapshot_download`，任务在 `transcribing` 阶段失败。

### 根因
- Apple Silicon 下优先走 MLX 路径时，模型从 HuggingFace 拉取。
- 运行环境存在代理链路时，TLS 握手偶发异常（EOF），导致下载中断。
- 下载未成功落盘时，本地缓存未建立，后续任务会再次触发下载尝试，体验上像“每次都在下载”。

### 修复
- 在 `electron/core/task-engine/TaskEngine.ts` 的 MLX 执行脚本中先尝试：
  - `snapshot_download(..., local_files_only=True)`（优先命中本地缓存）；
  - 本地无缓存时再走联网下载。
- 增加代理异常识别与兜底重试：
  - 捕获本次 stderr；
  - 若识别为代理/TLS 相关错误，自动进行一次“无代理环境变量”重试（清空 `HTTP(S)_PROXY/ALL_PROXY`，设置 `NO_PROXY=*`）。

### 验证
- `npm run lint -- electron/core/task-engine/TaskEngine.ts` 通过。
- `npx tsc --noEmit` 通过。
- 预期效果：首次下载成功后，同模型后续任务优先复用缓存；遇到代理 TLS 异常时可自动兜底重试。

---

## 问题 4：History 页面点击“恢复”报错 `No checkpoint found`

### 现象
- 在 `src/pages/HistoryPage.tsx` 点击“恢复”时，部分失败任务直接报 `No checkpoint found`，无法续跑。
- 该问题在“转录阶段失败”的任务上稳定出现。

### 根因
- `resumeFromCheckpoint` 旧逻辑强依赖 `task_recovery_snapshots`。
- 但 checkpoint 仅在分段阶段写入（翻译/合成成功分段后保存）；转录失败时通常没有 checkpoint。
- 因此恢复请求被直接拒绝。

### 修复
- 在 `electron/core/task-engine/TaskEngine.ts` 增加“无 checkpoint 的恢复兜底”：
  - 根据最近失败/运行的 step 推断首选恢复阶段；
  - 结合已有 artifact（video/audio/transcript/translation/tts）回退到可执行的最近阶段；
  - 若有未完成分段，自动构建 retry 集合。
- 即使没有 checkpoint，也可启动恢复流程，不再直接报错。

### 验证
- `npm run lint -- electron/core/task-engine/TaskEngine.ts` 通过。
- `npx tsc --noEmit` 通过。
- 手动验证：对转录阶段失败任务点击“恢复”可正常受理并重新进入执行。

## 后续观察点
- 关注日志中 `Translation merge removed duplicated overlap chars` 的出现频率与字符数。
- 如误删真实重复语句（如歌词副歌）出现，可在后续引入“阈值化去重”开关（按重叠比例/长度触发）。
- 关注日志 `MLX download hit proxy TLS error, retrying once without proxy env` 的出现频率，评估是否需要提供用户可配置代理策略。
- 关注“无 checkpoint 恢复”触发次数，若频繁触发可在历史页补充恢复来源说明（checkpoint/fallback）。

---

## 问题 5：DeepSeek 翻译阶段 `fetch failed`，误怀疑 API Key 未生效

### 现象
- 翻译阶段分段重试日志连续出现 `fetch failed`，并最终触发 `E_TRANSLATING_FAILED`。
- 同一任务启动日志显示：
  - `Resolved translation provider=deepseek, model=deepseek-chat, baseUrl=https://api.deepseek.com, apiKey=set`
- 设置页“翻译连通测试”可通过。

### 根因分析
- `apiKey=set` 表示运行时已读取到非空 DeepSeek Key，并非“未取到 key”。
- `fetch failed` 属于网络层失败（建连/DNS/TLS/代理链路），并非业务层 HTTP 错误（例如 401/403）。
- 任务执行使用创建时快照配置；若仅修改设置但复用旧任务，可能继续使用旧的 Base URL/参数。

### 处理结论
- 本次问题归因为网络瞬态，不是鉴权配置缺失。
- 操作建议：
  - 保持 Provider=`deepseek`、Model=`deepseek-chat`、Base URL=`https://api.deepseek.com`；
  - 修改设置后新建任务再跑，避免旧快照干扰；
  - 出现 `fetch failed` 时优先排查代理/DNS/TLS 链路。

### 验证
- 连通测试通过；
- 新建任务后翻译阶段可完成；
- 启动日志仍显示 `apiKey=set`，与预期一致。

---

## 问题 6：Piper 中文合成失败（exit code 1）且日志信息不足

### 现象
- 合成阶段多个分段同时失败：
  - `E_TTS_SEGMENT: Piper tts failed: Command failed with code 1 ...`
- 原始错误仅包含命令与退出码，不包含 Piper stderr 关键细节，定位成本高。

### 根因
- 中文语音模型（`zh_CN-chaowen-medium`）依赖 `piper-tts[zh]` 相关组件。
- 当前自动安装仅装了基础 `piper-tts`，缺少中文必需依赖，实际报错依次出现：
  - `No module named 'g2pw'`
  - `No module named 'requests'`
  - `No module named 'torch'`
  - `No module named 'unicode_rbnf'`
  - `No module named 'sentence_stream'`
- 由于命令执行器未回传 stderr 摘要，前端看起来只剩 “code 1”。

### 修复
- `electron/core/piper/installer.ts`
  - 安装流程按默认目标语言补依赖：当 `defaultTargetLanguage=zh` 时自动安装
    `g2pw`、`sentence-stream`、`unicode-rbnf`、`requests`、`torch`。
- `electron/core/task-engine/command.ts`
  - 命令失败时附带 stdout/stderr 摘要，便于直接定位真实异常。
- `electron/core/task-engine/minimax.ts`
  - Piper 调用增加 `--data-dir`，将 g2pW 资源缓存到模型目录 `.piper-data`，避免污染项目 cwd。
  - 捕获 `No module named ...` 并转换为可操作提示（含建议修复命令）。

### 验证
- `npx tsc --noEmit` 通过。
- `npm run lint` 通过。
- 本地命令复测 `piper ... --model zh_CN-chaowen-medium.onnx ...` 可成功生成 wav（exit=0）。

---

## 问题 7：未来多语言模型选择策略不严格（需“无支持即报错”）

### 现象
- 旧逻辑在目标语言未匹配到音色时会回退到英文/任意音色，存在“语言不一致但不报错”的风险。

### 根因
- `pickVoiceByLanguage(...)` 包含过宽回退路径：语言匹配失败后继续尝试英文，再退到首个音色。

### 修复
- `electron/core/piper/installer.ts`
  - 移除跨语言兜底回退；
  - 改为严格匹配：只要当前语言找不到可用音色，直接抛出明确错误并列出当前可用音色样本。

### 验证
- `defaultTargetLanguage=en` 时会自动选择并下载英文音色；
- 若对应语言无可用音色，安装阶段明确报错，不再静默回退到其他语言模型。

## 新增后续观察点
- 关注 `fetch failed` 的出现频率，若网络抖动仍频发，可补充对 `error.cause`（如 `ENOTFOUND/ECONNRESET/ETIMEDOUT`）的显式日志。
- 关注 Piper 首次中文合成时 `.piper-data` 下载耗时，必要时在 UI 增加“首次初始化”提示。
- 关注语言不匹配报错反馈量，评估是否在设置页提前做“语言->可用音色”预校验提示。
